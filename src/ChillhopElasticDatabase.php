<?php

/**
 * This library is written to conform the PHP PSR-1 standard:
 * https://www.php-fig.org/psr/psr-1/
 */

namespace ChillhopMusic\ElasticSearch;

use Elasticsearch\ClientBuilder;
use Elasticsearch\Client;
use Exception;
use DateTime;
use DateTimeZone;

function getUtcDate(): DateTime {
    return new DateTime('now', new DateTimeZone('UTC'));
}

/**
 * This class provides a base for creating ElasticSearch interfaces for Chillhop applications
 */
abstract class ChillhopElasticDatabase {
    protected Client $_client;
    protected string $_indexPrefix;
    protected string $_lastIndexName;
    protected array $_mappings;

    protected abstract function createItemId(object $item): string|null;
    protected abstract function getIndexNameWithPrefix(string $indexPrefix, DateTime $utcDate): string;
    public abstract function getItemDate(object $item): DateTime|null;

    /**
     * Creates a new Chillhop ElasticSearch interface
     *
     * @param Client|null $client ElasticSearch client
     * @param string $indexPrefix Prefix for the indices (e.g. "stats_youtube_")
     * @param object $mappings ElasticSearch data type mappings
     */
    public function __construct(Client $client = null, string $indexPrefix, array $mappings) {
        if ($client) {
            $this->_client = $client;
        } else {
            $this->_client = ClientBuilder::create()->build();
        }
        $this->_indexPrefix = $indexPrefix;
        $this->_lastIndexName = "";
        $this->_mappings = $mappings;
    }

    /** Index prefix */
    public function getIndexPrefix(): string {
        return $this->_indexPrefix;
    }

    /**
     * Get index name for a given date
     * @param DateTime $date Date to get the index name for
     * @return Index name consisting of prefix and date
     */
    public function getIndexName(DateTime $date): string {
        return $this->getIndexNameWithPrefix($this->_indexPrefix, $date);
    }

    /**
     * Gets index name for current UTC date and create index if not exists
     * @param DateTime $date Date to create the index for
     * @return index name for current UTC date
     */
    protected function getCurrentIndexNameAndCreateIfNotExists(DateTime $date): string {
        $newIndexName = $this->getIndexNameWithPrefix($this->_indexPrefix, $date);
        if ($newIndexName != $this->_lastIndexName) {
            $this->createIndexIfNotExists($newIndexName, $this->_mappings);
        }
        $this->_lastIndexName = $newIndexName;
        return $newIndexName;
    }

    /**
     * Bulk indexes multiple items. If index does not exist, index will be created automatically
     * @param array $elasticItems Items to index
     * @param string $index Optional index to index the item to. If not specified, index name will be generated by getIndexName passed in the constructor
     * @returns Promise that resolved with Bulk import stats
     */
    public function bulkIndex(array $items, string $index = null) {
        $params = ['body' => []];

        $i = 0;
        foreach ($items as $item) {
            $itemId = $this->createItemId($item);
            $date = $this->getItemDate($item) ?? getUtcDate();
            $indexName = $index ?? $this->getCurrentIndexNameAndCreateIfNotExists($date);

            if ($itemId != null) {
                $params['body'][] = [
                    'index' => [
                        '_index' => $indexName,
                        '_id'    => $itemId
                    ]
                ];
            } else {
                $params['body'][] = [
                    'index' => [
                        '_index' => $indexName,
                    ]
                ];
            }

            $params['body'][] = $item;
            $i++;

            // Every 1000 documents stop and send the bulk request
            if ($i % 1000 == 0) {
                $responses = $this->_client->bulk($params);

                // erase the old bulk request
                $params = ['body' => []];

                // unset the bulk response when you are done to save memory
                unset($responses);
            }
        }

        // Send the last batch if it exists
        if (!empty($params['body'])) {
            $responses =  $this->_client->bulk($params);
        }
    }

    /**
     * Indexes a single item
     * @param mixed $item Item to index
     * @param string $index Index to index the item to. If not specified, index name will be generated by getIndexName passed in the constructor
     * @return array ElasticSearch API response
     */
    public function index(mixed $item, string $index = null) {
        $date = $this->getItemDate($item) ?? getUtcDate();
        $indexName = $index ?? $this->getCurrentIndexNameAndCreateIfNotExists($date);

        $params = [
            'index' => $indexName,
            'body' => $item
        ];

        $itemId = $this->createItemId($item);
        if ($itemId != null) {
            $params['id'] = $itemId;
        }

        $result = $this->_client->index($params);

        //print_r($result);
    }

    /**
     * Check if a record with a given ID exists
     * @param string $id ID to check
     * @param DateTime $date Date of the item to look for
     * @param string $index Optional index to force searching in a specific index
     * @return bool true if a record with the given ID exists
     */
    public function recordExists(string $id, DateTime $date, string $index = null): bool {
        $indexName = $index ?? $this->getCurrentIndexNameAndCreateIfNotExists($date);

        $params = [
            'index' => $indexName,
            'body' => [
                'size' => 0,
                'query' => [
                    'match' => [
                        '_id' => $id
                    ]
                ]
            ]
        ];

        $results = $this->_client->search($params);

        if (is_array($results) && $results["hits"]["total"]["value"]) {
            return true;
        }
        return false;
    }

    /**
     * Create index if it doesn't exist. If index exists, fails quietly
     * @param string $indexName Index name
     * @param array $mappings ElasticSearch Mappings
     * @throws Exception if mappings are invalid or index cannot be created.
     * @return bool true if new index is created, false if index already existed
     */
    public function createIndexIfNotExists(string $indexName, array $mappings): bool {
        $params = [
            'index' => $indexName,
            'body' => [
                'mappings' => [
                    'properties' => $mappings
                ]
            ]
        ];

        try {
            $response = $this->_client->indices()->create($params);
            if ($response['acknowledged']) {
                return true;
            }
            return false;
        } catch (Exception $err) {
            try {
                $errArray = json_decode($err->getMessage());
                if ($errArray->error?->type == 'resource_already_exists_exception') {
                    //echo "Resource exists";
                    return false;
                }
            } catch (Exception $jsonErr) {
                throw $err;
            }
            //print_r(json_decode($err->getMessage()));
        }
        return true;
    }
}
